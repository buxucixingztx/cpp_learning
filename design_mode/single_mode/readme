c++常用设计模式  --- 单例模式
参考博客：https://www.cnblogs.com/chengjundu/p/8473564.html

单例模式顾名思义，保证一个类仅可以有一个实例化对象，并且提供一个可以访问它的全局接口。实现单例模式必须
注意以下几点：
    单例类只能由一个实例化对象。
    单例类必须自己提供一个实例化对象。
    单例类必须提供一个可以访问唯一实例化对象的接口。

1. 懒汉单例模式
懒汉：顾名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化一个对象。
在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，这是以时间换空间。

1.1 非线程安全的懒汉单例模式
关键代码：构造函数是私有的，不能通过赋值运算，拷贝构造等方式实例化对象。
步骤：
    在实现单例类的时候，将构造函数放在私有函数中，留下一个公有函数的接口来产生实例；
    先定义好一个单例类的示例，指针指向NULL；
    在实现公有函数的接口时，先判断该单例类的实例是否指向NULL，如果指向NULL，就构造一个新实例，否则就返回已有实例。

1.2 线程安全的懒汉单例模式
关键代码：使用锁来控制每次生成单例时只能一个线程访问。
步骤：  
    在实现单例类的时候，将构造函数放在私有函数中，留下一个公有函数的接口来产生实例；
    先定义好一个单例类的示例，指针指向NULL；
    在实现公有函数的接口时，先判断该单例类的实例是否指向NULL，如果指向NULL，就构造一个新实例，否则就返回已有实例。
注：为了保证线程安全，在每次生成单例时，进行加锁，保证只能有一个线程生成实例。

1.3 返回一个reference指向local static对象
在程序的单线程启动阶段手工调用所有reference-returning函数。
这种实现方式的好处是不需要去delete它。
步骤：
    在实现单例类的时候，将构造函数放在私有函数中，留下一个公有函数的接口来产生实例；
    共有函数声明一个静态单例类实例，然后返回该实例。

2. 饿汉单例模式
饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，
可以实现更好的性能。这是以空间换时间。
步骤：  
    在实现单例类的时候，将构造函数放在私有函数中，留下一个公有函数的接口来产生实例；
    然后提前new出来一个单例类实例，在每次调用的时候，直接返回这个实例。