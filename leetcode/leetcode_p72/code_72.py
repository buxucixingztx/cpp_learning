# 力扣第72题，编辑距离
"""
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：
    1. 插入一个字符
    2. 删除一个字符
    3. 替换一个字符
"""

"""
编辑距离算法是用作机器翻译和语音识别评价标准的基本算法。

最直观的方法是暴力检查所有可能的编辑方法，取最短的一个，所有可能的编辑方法达到指数级。


方法：动态规划

思路和算法
我们可以对任意一个单词进行三种操作：
    1. 插入一个字符；
    2. 删除一个字符；
    3. 替换一个字符；

题目给定了两个单词，设为A和B，这样我们就能够六种操作方法。
但实际上对A进行的操作和对B进行的反操作是一样的。
    对单词A删除一个字符和对单词B插入一个字符是等价的。
    对单词B删除一个字符和对单词A插入一个字符是等价的。
    对单词A替换一个字符和对单词B替换一个字符是等价的。

这样实际上的操作有啥三种：
    在单词A中插入一个字符；
    在单词B中插入一个字符；
    修改单词A的一个字符；

这样就可以把原问题转化为规模较小的子问题了。以A=horse, B=ros为例。
    1. 在单词A中插入一个字符：如果我们知道horse到ro的编辑距离为a，那么显然horse到ros的编辑距离不会超过a+1.
    这是因为我们可以在a次操作后将horse和ro变为相同的字符串，只需要额外的1次操作，在单词A的末尾添加字符s，
    就能在a+1次操作后将horse和ro变为相同的字符串；

    2. 在单词B中插入一个字符：如果我们知道hors到ros的编辑距离为b，那么显然horse到ros的编辑距离不会超过b+1.

    3. 修改单词A的一个字符：如果我们知道hors到ro的编辑距离为c，那么显然horse到ros的编辑距离刽超过c+1，原因同上。
那么从horse变成ros的编辑距离应该为min(a+1, b+1, c+1)。

注意：为什么我们总是在单词A和B的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序不影响
最终的结果。例如对单词cat，我们希望在c和a之间添加字符d并且将字符t修改为字符b，那么这两个操作无论为什么顺序，都会得到最终的结果cdab。

我们可以继续拆分，直到：
   1. 字符串A为空，从''转换到ro，显然编辑距离为字符串B的长度，这里是2；
   2. 字符串B为空，从horse到'', 显然编辑距离为字符串A的长度，这里是5。

因此，我们可以使用动态规划来解决这个问题，我们用dp[i][j]表示A的前i个字母和B的前j个字母之间的编辑距离。

如上所述，当我们获得dp[i][j-1], dp[i-1][j]和dp[i-1][j-1]的值之后，就可以计算出dp[i][j]。
    1. dp[i][j-1]为A的前i个字符和B的前j-1个字符编辑距离的子问题。即对于B的第j个字符，我们在A的末尾添加了一个相同的字符，
    那么dp[i][j]最小可以为dp[i][j-1]+1;
    2. dp[i-1][j]为A的前i-1个字符和B的前j个字符编辑距离的子问题。即对于A的第i个字符，我们在B的末尾添加了一个相同的字符，
    那么dp[i][j]最小可以为dp[i-1][j]+1;
    3. dp[i-1][j-1]为A的前i-1个字符和B的前j-1个字符编辑距离的子问题。即对于B的第j个字符，我们修改A的第i个字符使它们相同，
    那么d[i][j]最小可以为dp[i-1][j-1]+1。特别地，如果A的第i个字符和B的第j个字符原本就相同，那么我们实际上不需要进行修改操作。
    在这种情况下，dp[i][j]最小可以为dp[i-1][j-1]。

那么我们可以写出如下的状态转移方程：
   若A和B的最后一个字母相同：
    d[i][j] = min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1])
            = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]-1)
    
    若A和B的最后一个字母不同：
    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
所以每一步结果都将基于上一步的计算结果。

对于边界情况，一个空串和一个非空串的编辑距离为dp[i][0]=i, dp[0][j]=j, dp[i][0]相当于对word1执行i次删除操作，
dp[0][j]相当于对word1执行j次插入操作。
"""

# word1 = 'horse'
# word2 = 'ros'

word1 = 'intention'
word2 = 'execution'

dp = [[0 for _ in range(len(word1)+1)] for _ in range(len(word2)+1)]
print(dp)

for i in range(len(word2)+1):
    dp[i][0] = i
for i in range(len(word1)+1):
    dp[0][i] = i

for i,iv in enumerate(word2):
    for j,jv in enumerate(word1):
        if iv == jv:
            ijv = min(dp[i][j]-1, dp[i][j+1], dp[i+1][j]) + 1
        else:
            ijv = min(dp[i][j], dp[i][j+1], dp[i+1][j]) + 1
        
        dp[i+1][j+1] = ijv


print(dp)