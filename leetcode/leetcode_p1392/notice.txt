力扣1392题，最长快乐前缀
【快乐前缀】是在原字符串中既是非空前缀也是后缀（不包括原字符串自身）的字符串
给定一个字符串s，返回它的最长快乐前缀


快乐前缀并不快乐(哭笑)，做的我比较难受，主要是在看KMP算法时特别痛苦。
说一下本题的三个解答思路。

1、暴力破解
遍历原字符串，遍历过程中累加子字符串，如果发现子字符串和最后面的等长的子串相等，则更新最长的快乐子串。

2、Rabin-Karp字符串编码
跟暴力破解类似，不过是对子串进行了编码，然后对比前后子串的编码值是否相等。

3、KMP算法
使用一个匹配数组(fail或next)，其中fail[i]表示关于字符串s的子串s[0..i]最长的即是前缀也是后缀的字符串。
代码如下：
string s;
vector<int> fail(n, -1);
for (int i = 1; i < n; ++i)
{
    int j = fail[i-1];
    while (j != -1 && s[j+1] != s[i])
        j = fail[j];
    if s[j+1] == s[i]:
        fail[i] = j + 1;
}
return s.substr(0, fail[n-1]+1);

为了理解整个过程，我在python环境下，逐步debug来分析每个变量的变化；
但最难理解的是while循环，这个一步更新j值的操作。
正常情况下，如果上一个i值对应上了j值，那么本轮的j值就不再是-1，为此我们需要判断本轮的i值和j+1值是否对应，
如果对应，则累加匹配，否则，需要更新j值。从0开始匹配可能会漏掉一些情况，所以我们将j值移动到前一步连续匹配的子串的最后位置。